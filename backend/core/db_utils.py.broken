"""
Database utility layer with sync_to_async wrappers.
Routes between PostgreSQL and MongoDB based on USE_MONGODB setting.
"""
import logging
from typing import Dict, Any, List, Optional
from asgiref.sync import sync_to_async
from django.conf import settings
from .models import Post, Collection, TryOn, User
from .mongo_manager import get_mongo_manager
from .keyword_extractor import extract_nail_keywords

logger = logging.getLogger(__name__)


def _use_mongodb() -> bool:
    """Check if MongoDB should be used."""
    return getattr(settings, 'USE_MONGODB', False)


# ==================== POST OPERATIONS ====================

def get_filtered_posts(
    q: Optional[str] = None,
    shape: Optional[str] = None,
    pattern: Optional[str] = None,
    size: Optional[str] = None,
    color: Optional[str] = None,
    page: int = 1,
    page_size: int = 48,
    enable_fallback: bool = False
) -> Dict[str, Any]:
    """
    Get filtered posts with pagination.
    Routes to MongoDB or PostgreSQL based on USE_MONGODB flag.
    
    Args:
        enable_fallback: If True and results < 10, trigger similar search fallback
    """
    if _use_mongodb():
        try:
            # Extract keywords if text query provided
            extracted_keywords = None
            remaining_query = None
            
            if q:
                extracted_keywords, remaining_query = extract_nail_keywords(q)
            
            # Call MongoDB manager (now synchronous)
            mongo_manager = get_mongo_manager()
            
            # Choose method based on fallback setting
            if enable_fallback:
                result = mongo_manager.search_with_fallback(
                    q=q,
                    shape=shape,
                    pattern=pattern,
                    size=size,
                    color=color,
                    page=page,
                    page_size=page_size,
                    extracted_keywords=extracted_keywords,
                    remaining_query=remaining_query,
                    fallback_threshold=10
                )
            else:
                result = mongo_manager.filter_posts(
                    q=q,
                    shape=shape,
                    pattern=pattern,
                    size=size,
                    color=color,
                    page=page,
                    page_size=page_size,
                    extracted_keywords=extracted_keywords,
                    remaining_query=remaining_query
                )
            
            return result
        
        except Exception as e:
            logger.error(f"MongoDB query failed, falling back to PostgreSQL: {e}")
            # Fall through to PostgreSQL
    
    # PostgreSQL fallback (existing Django ORM logic)
    from django.db.models import Q
    from functools import reduce
    import operator
    from .color_constants import COLOR_SIMPLIFICATION_MAP
    
    queryset = Post.objects.all()
    query_filters = Q()
    
    # ... (existing filter logic from views.py FilteredPostListView)
    # This would be the same as the current implementation
    
    # For now, return basic implementation
    # TODO: Move full ORM logic here
    posts = list(queryset.order_by('-created_at')[(page-1)*page_size:page*page_size])
    total_count = queryset.count()
    
    from .serializers import PostSerializer
    results = PostSerializer(posts, many=True).data
    
    import random
    return {
        'results': results,
        'count': total_count,
        'next': f'?page={page+1}' if (page*page_size) < total_count else None,
        'previous': f'?page={page-1}' if page > 1 else None,
        'seed': random.randint(1000, 9999),
    }


def get_post_by_id(post_id: str) -> Optional[Dict[str, Any]]:
    """Get single post by ID."""
    if _use_mongodb():
        try:
            mongo_manager = get_mongo_manager()
            
            try:
            result = mongo_manager.get_post_by_id(post_id)
            return result
        except Exception as e:
            logger.error(f"MongoDB get_post failed: {e}")
    
    # PostgreSQL fallback
    try:
        post = Post.objects.get(id=int(post_id))
        from .serializers import PostSerializer
        return PostSerializer(post).data
    except (Post.DoesNotExist, ValueError):
        return None


def get_similar_posts(post_id: str, count: int = 48) -> List[Dict[str, Any]]:
    """Get posts similar to a given post."""
    if _use_mongodb():
        try:
            mongo_manager = get_mongo_manager()
            result = sync_to_async(mongo_manager.get_similar_posts)(post_id, count)
            
            try:
            result = sync_to_async(mongo_manager.get_user_collections)(user_id, page, page_size)
            
            try:
            get_coll_result = sync_to_async(mongo_manager.get_collection_by_id)(collection_id)
            get_posts_result = sync_to_async(mongo_manager.get_collection_posts)(collection_id, page=1, page_size=1000)
            
            try:
            result = sync_to_async(mongo_manager.create_collection)(user_id, name)
            
            try:
            result = sync_to_async(mongo_manager.add_post_to_collection)(collection_id, post_id)
            
            try:
            result = sync_to_async(mongo_manager.remove_post_from_collection)(collection_id, post_id)
            
            try:
            result = sync_to_async(mongo_manager.create_tryon)(user_id, post_id)
            
            try:
            result = sync_to_async(mongo_manager.get_user_tryons)(user_id, page, page_size)
            
            try:
            result = sync_to_async(mongo_manager.delete_tryon)(tryon_id)
            
            try:
